# stm32-memory

STM32 memory and bootloader process explained.

## Build
```sh
mkdir build; cd build
cmake ../
make
```

## Memory

There're two basic memory peripherals present in SMT32F4:

* **RAM** stores data produced by the running programm. Using heap or stack abstractions for memory management.
* **FLASH** keeps the program binary and constants, used by bootloader to initialize RAM on startup.

Even though all examples below are for STM32F4, basic principles apply to pretty much all STM32s.

### Linker File

```c
// STM32F446RETx_FLASH.ld

MEMORY
{
  RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 128K
  FLASH (rx) : ORIGIN = 0x8000000, LENGTH = 512K
}
```

## Sections

To explore .elf symbol table we'll be using the following command:
```sh
arm-none-eabi-objdump -t stm32-memory.elf | sort
```
And reference to our default linker file [STM32F446RETx_FLASH.ld](./src/STM32F446RETx_FLASH.ld) generated by STM32CubeMX.


### .text 
Compiled programm code goes into this section in **FLASH** memory.

The section starts from the flash's `ORIGIN` address. And `_etext` points to the last address of the section.

```c
08000000 l    d  .text	00000000 .text
080005c4 g       .text	00000000 _etext
```

We could see the location of the functions, that we use in our bootloader file:

```c
08000404 g     F .text	00000048 __libc_init_array
0800044c g     F .text	000000d8 main
08000524 g     F .text	00000064 Reset_Handler
08000588 g     F .text	00000024 SystemInit
```

### .data

The section resides in **RAM** memory and keeps all _defined_ variables values. Address range spans from `_sdata` to `_edata`.


```c
20000000 g       .data	00000000 _sdata
20000010 g       .data	00000000 _edata
```

Our defined variables from `main.c` are residing in this section:
```c
20000000 l     O .data	00000004 static_defined_int
20000008 g     O .data	00000008 defined_double
```

Actual values must be filled by a bootloader script by copying data from **FLASH** memory at address `_sidata`:
```c
080005cc g       *ABS*	00000000 _sidata
```

### .bss

Block Starting Symbol **RAM** data section for all _declared_ variables. That means that they have no value yet and the bootloader takes care of setting this block's data to `0`.

Memory range spans from `_sbss` to `_ebss`.
```c
20000010 g       .bss	00000000 _sbss
20000044 g       .bss	00000000 _ebss
```

Our declared variables from `main.c` are residing in this section:
```c
2000002c l     O .bss	00000004 static_declared_int
20000030 g     O .bss	00000008 declared_double
20000038 g     O .bss	00000008 declared_my_struct
20000040 g     O .bss	00000004 declared_my_union
```

### ._user_heap_stack

All **RAM** memory above `_end` and until `_estack` is dedicated to heap and stack memory.

```c
20000048 g       ._user_heap_stack	00000000 _end
20020000 g       *ABS*	00000000 _estack
```

Stack is a LIFO structure that starts at `_estack` and grows downwards. Min stack size is defined in the linker file as `_Min_Stack_Size`. Stack memory is freed automatically.

Heap in turns starts from `_end` and grows upwards up to `_estack - _Min_Stack_Size`. Heap memory is managed by `malloc` and `free` C functions. See the default implementation for `sbrk`, which is called by `malloc` in [sysmem.c](./src/sysmem.c).

## Boot Process